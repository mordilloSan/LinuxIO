package docker

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/mordilloSan/go-logger/logger"
)

type Metrics struct {
	CPUPercent float64 `json:"cpu_percent"`
	MemUsage   uint64  `json:"mem_usage"`
	MemLimit   uint64  `json:"mem_limit"`
	NetInput   uint64  `json:"net_input"`
	NetOutput  uint64  `json:"net_output"`
	BlockRead  uint64  `json:"block_read"`
	BlockWrite uint64  `json:"block_write"`
}

type ContainerWithMetrics struct {
	types.Container
	Metrics *Metrics `json:"metrics,omitempty"`
	Icon    string   `json:"icon,omitempty"`
	URL     string   `json:"url,omitempty"`
}

// List all containers with metrics
func ListContainers() (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	containers, err := cli.ContainerList(context.Background(), container.ListOptions{All: true})
	if err != nil {
		return nil, fmt.Errorf("failed to list containers: %w", err)
	}

	var enriched []ContainerWithMetrics

	for _, ctr := range containers {
		metrics := &Metrics{}
		statsResp, err := cli.ContainerStatsOneShot(context.Background(), ctr.ID)
		if err == nil {
			var stats struct {
				CPUStats struct {
					CPUUsage struct {
						TotalUsage  uint64   `json:"total_usage"`
						PercpuUsage []uint64 `json:"percpu_usage"`
					} `json:"cpu_usage"`
					SystemCPUUsage uint64 `json:"system_cpu_usage"`
				} `json:"cpu_stats"`
				MemoryStats struct {
					Usage uint64 `json:"usage"`
					Limit uint64 `json:"limit"`
				} `json:"memory_stats"`
				Networks map[string]struct {
					RxBytes uint64 `json:"rx_bytes"`
					TxBytes uint64 `json:"tx_bytes"`
				} `json:"networks"`
				BlkioStats struct {
					IoServiceBytesRecursive []struct {
						Op    string `json:"op"`
						Value uint64 `json:"value"`
					} `json:"io_service_bytes_recursive"`
				} `json:"blkio_stats"`
			}

			if err := json.NewDecoder(statsResp.Body).Decode(&stats); err == nil {
				// CPU as before
				cpuDelta := float64(stats.CPUStats.CPUUsage.TotalUsage)
				systemDelta := float64(stats.CPUStats.SystemCPUUsage)
				if systemDelta > 0 && len(stats.CPUStats.CPUUsage.PercpuUsage) > 0 {
					metrics.CPUPercent = (cpuDelta / systemDelta) * float64(len(stats.CPUStats.CPUUsage.PercpuUsage)) * 100.0
				}

				metrics.MemUsage = stats.MemoryStats.Usage
				metrics.MemLimit = stats.MemoryStats.Limit

				// net & block as before...
				for _, net := range stats.Networks {
					metrics.NetInput += net.RxBytes
					metrics.NetOutput += net.TxBytes
				}
				for _, entry := range stats.BlkioStats.IoServiceBytesRecursive {
					switch entry.Op {
					case "Read":
						metrics.BlockRead += entry.Value
					case "Write":
						metrics.BlockWrite += entry.Value
					}
				}
			}
			if cerr := statsResp.Body.Close(); cerr != nil {
				logger.Warnf("failed to close container stats body: %v", cerr)
			}
		}

		// Extract icon and URL from container labels
		containerIcon := ctr.Labels["io.linuxio.container.icon"]
		containerURL := ctr.Labels["io.linuxio.container.url"]

		// Determine best name for icon resolution
		var iconName string
		if len(ctr.Names) > 0 {
			containerName := strings.TrimPrefix(ctr.Names[0], "/")
			serviceName := ctr.Labels["com.docker.compose.service"]
			projectName := ctr.Labels["com.docker.compose.project"]

			// Check if container name is auto-generated by compose (format: project-service-replica)
			// If it matches this pattern, prefer service name; otherwise use container name
			if serviceName != "" && projectName != "" {
				// Try to detect auto-generated name: should start with project- and end with -number
				expectedPrefix := projectName + "-" + serviceName + "-"
				if strings.HasPrefix(containerName, expectedPrefix) {
					// Auto-generated name like "teste-pihole-1", use service name
					iconName = serviceName
				} else {
					// User-defined container_name like "pi-hole", use it
					iconName = containerName
				}
			} else {
				// Non-compose container, use container name
				iconName = containerName
			}
		}

		// Resolve icon with fallback to determined name
		iconIdentifier := ResolveIconIdentifier(containerIcon, iconName)

		enriched = append(enriched, ContainerWithMetrics{
			Container: ctr,
			Metrics:   metrics,
			Icon:      iconIdentifier,
			URL:       containerURL,
		})
	}

	return enriched, nil
}

// Start a container by ID
func StartContainer(id string) (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	if err := cli.ContainerStart(context.Background(), id, container.StartOptions{}); err != nil {
		return nil, fmt.Errorf("failed to start container: %w", err)
	}

	return "started", nil
}

// Stop a container by ID
func StopContainer(id string) (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	if err := cli.ContainerStop(context.Background(), id, container.StopOptions{}); err != nil {
		return nil, fmt.Errorf("failed to stop container: %w", err)
	}

	return "stopped", nil
}

// Remove a container by ID
func RemoveContainer(id string) (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	if err := cli.ContainerRemove(context.Background(), id, container.RemoveOptions{Force: true}); err != nil {
		return nil, fmt.Errorf("failed to remove container: %w", err)
	}

	return "removed", nil
}

// Restart a container by ID
func RestartContainer(id string) (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	if err := cli.ContainerRestart(context.Background(), id, container.StopOptions{}); err != nil {
		return nil, fmt.Errorf("failed to restart container: %w", err)
	}

	return "restarted", nil
}

// StartAllStopped starts all exited/dead containers and returns counts.
func StartAllStopped() (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	ctx := context.Background()
	containers, err := cli.ContainerList(ctx, container.ListOptions{All: true})
	if err != nil {
		return nil, fmt.Errorf("failed to list containers: %w", err)
	}

	started, failed := 0, 0
	for _, c := range containers {
		if c.State == "exited" || c.State == "dead" {
			if err := cli.ContainerStart(ctx, c.ID, container.StartOptions{}); err != nil {
				logger.Warnf("failed to start container %s: %v", c.ID[:12], err)
				failed++
			} else {
				started++
			}
		}
	}

	return map[string]any{"started": started, "failed": failed}, nil
}

// StopAllRunning stops all running containers and returns counts.
func StopAllRunning() (any, error) {
	cli, err := getClient()
	if err != nil {
		return nil, fmt.Errorf("docker client error: %w", err)
	}
	defer func() {
		if cerr := cli.Close(); cerr != nil {
			logger.Warnf("failed to close Docker client: %v", cerr)
		}
	}()

	ctx := context.Background()
	containers, err := cli.ContainerList(ctx, container.ListOptions{All: true})
	if err != nil {
		return nil, fmt.Errorf("failed to list containers: %w", err)
	}

	stopped, failed := 0, 0
	for _, c := range containers {
		if c.State == "running" {
			if err := cli.ContainerStop(ctx, c.ID, container.StopOptions{}); err != nil {
				logger.Warnf("failed to stop container %s: %v", c.ID[:12], err)
				failed++
			} else {
				stopped++
			}
		}
	}

	return map[string]any{"stopped": stopped, "failed": failed}, nil
}
